#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2024::*;
#[macro_use]
extern crate std;
mod parser {
    use json::{Json, Pair};
    use std::{fmt::Debug, str::FromStr};
    use timing_macro::time_function;
    enum JsonError {
        Pair(String),
        Key(String),
        Value(String),
    }
    impl Debug for JsonError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match self {
                Self::Pair(pair) => {
                    f.debug_struct("JsonError").field(" Pair", &pair).finish()
                }
                Self::Key(key) => f.debug_struct("JsonError").field("Key", &key).finish(),
                Self::Value(value) => {
                    f.debug_struct("JsonError").field("Value", &value).finish()
                }
            }
        }
    }
    struct JsonWrapper(Json);
    struct PairWrapper(Pair);
    impl FromStr for JsonWrapper {
        type Err = JsonError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let mut pairs = Vec::new();
            for object in s
                .split_once(':')
                .unwrap()
                .1
                .split_once('[')
                .unwrap()
                .1
                .split('{')
                .skip(1)
            {
                match object.parse::<PairWrapper>() {
                    Ok(p) => pairs.push(p.0),
                    Err(e) => return Err(e),
                }
            }
            Ok(JsonWrapper(Json { pairs }))
        }
    }
    fn parse_f64(s: &str) -> Result<f64, JsonError> {
        use platform_metrics::read_cpu_timer;
        use timing_macro::time_block;
        use crate::{TIMING_STACK, TIMED};
        let output = {
            use crate::Timer;
            let timer = Timer::new("parse_f64");
            if s.contains('}') {
                return parse_f64(s.split_once('}').unwrap().0);
            }
            match s.parse::<f64>() {
                Ok(v) => Ok(v),
                Err(_) => Err(JsonError::Value(s.to_string())),
            }
        };
        output
    }
    impl FromStr for PairWrapper {
        type Err = JsonError;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            use platform_metrics::read_cpu_timer;
            use timing_macro::time_block;
            use crate::{TIMING_STACK, TIMED};
            let output = {
                use crate::Timer;
                let timer = Timer::new("from_str");
                let mut pair = Pair {
                    x0: 0.0,
                    y0: 0.0,
                    x1: 0.0,
                    y1: 0.0,
                };
                for kv in s.split(',') {
                    if kv.is_empty() {
                        continue;
                    }
                    match kv.split_once(':') {
                        Some((key, value)) => {
                            match key {
                                "\"x0\"" => pair.x0 = parse_f64(value)?,
                                "\"x1\"" => pair.x1 = parse_f64(value)?,
                                "\"y0\"" => pair.y0 = parse_f64(value)?,
                                "\"y1\"" => pair.y1 = parse_f64(value)?,
                                _ => return Err(JsonError::Key(key.to_string())),
                            }
                        }
                        None => return Err(JsonError::Pair(kv.to_string())),
                    }
                }
                Ok(PairWrapper(pair))
            };
            output
        }
    }
    /// ! __Not a general use json parser__ !
    ///
    /// Parses the json::Json object from a string.
    ///
    /// Assumes string is a json string formatted as:
    /// ```json
    /// {
    ///     "pairs": [
    ///         {
    ///             "x0": <f64>,
    ///             "y0": <f64>,
    ///             "x1": <f64>,
    ///             "y1": <f64>
    ///         },
    ///         ...
    ///     ]
    /// }
    /// ```
    pub fn parse(input: &str) -> Json {
        use platform_metrics::read_cpu_timer;
        use timing_macro::time_block;
        use crate::{TIMING_STACK, TIMED};
        let output = {
            use crate::Timer;
            let timer = Timer::new("parse");
            input.parse::<JsonWrapper>().expect("error parsing json").0
        };
        output
    }
}
use clap::Parser;
use haversine::haversine;
use parser::parse;
use std::fs;
use timing_macro::{time_block, time_main};
#[command(version, about)]
pub struct Args {
    /// input json file path
    #[arg(short, long, require_equals(false))]
    pub json_path: String,
    /// answer file path
    #[arg(short, long, require_equals(false))]
    pub answer_path: Option<String>,
}
#[automatically_derived]
#[allow(unused_qualifications, clippy::redundant_locals)]
impl clap::Parser for Args {}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
    clippy::redundant_locals,
)]
#[automatically_derived]
impl clap::CommandFactory for Args {
    fn command<'b>() -> clap::Command {
        let __clap_app = clap::Command::new("parser");
        <Self as clap::Args>::augment_args(__clap_app)
    }
    fn command_for_update<'b>() -> clap::Command {
        let __clap_app = clap::Command::new("parser");
        <Self as clap::Args>::augment_args_for_update(__clap_app)
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
    clippy::redundant_locals,
)]
#[automatically_derived]
impl clap::FromArgMatches for Args {
    fn from_arg_matches(
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        Self::from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn from_arg_matches_mut(
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<Self, clap::Error> {
        #![allow(deprecated)]
        let v = Args {
            json_path: __clap_arg_matches
                .remove_one::<String>("json_path")
                .ok_or_else(|| clap::Error::raw(
                    clap::error::ErrorKind::MissingRequiredArgument,
                    "The following required argument was not provided: json_path",
                ))?,
            answer_path: __clap_arg_matches.remove_one::<String>("answer_path"),
        };
        ::std::result::Result::Ok(v)
    }
    fn update_from_arg_matches(
        &mut self,
        __clap_arg_matches: &clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        self.update_from_arg_matches_mut(&mut __clap_arg_matches.clone())
    }
    fn update_from_arg_matches_mut(
        &mut self,
        __clap_arg_matches: &mut clap::ArgMatches,
    ) -> ::std::result::Result<(), clap::Error> {
        #![allow(deprecated)]
        if __clap_arg_matches.contains_id("json_path") {
            #[allow(non_snake_case)]
            let json_path = &mut self.json_path;
            *json_path = __clap_arg_matches
                .remove_one::<String>("json_path")
                .ok_or_else(|| clap::Error::raw(
                    clap::error::ErrorKind::MissingRequiredArgument,
                    "The following required argument was not provided: json_path",
                ))?;
        }
        if __clap_arg_matches.contains_id("answer_path") {
            #[allow(non_snake_case)]
            let answer_path = &mut self.answer_path;
            *answer_path = __clap_arg_matches.remove_one::<String>("answer_path");
        }
        ::std::result::Result::Ok(())
    }
}
#[allow(
    dead_code,
    unreachable_code,
    unused_variables,
    unused_braces,
    unused_qualifications,
)]
#[allow(
    clippy::style,
    clippy::complexity,
    clippy::pedantic,
    clippy::restriction,
    clippy::perf,
    clippy::deprecated,
    clippy::nursery,
    clippy::cargo,
    clippy::suspicious_else_formatting,
    clippy::almost_swapped,
    clippy::redundant_locals,
)]
#[automatically_derived]
impl clap::Args for Args {
    fn group_id() -> Option<clap::Id> {
        Some(clap::Id::from("Args"))
    }
    fn augment_args<'b>(__clap_app: clap::Command) -> clap::Command {
        {
            let __clap_app = __clap_app
                .group(
                    clap::ArgGroup::new("Args")
                        .multiple(true)
                        .args({
                            let members: [clap::Id; 2usize] = [
                                clap::Id::from("json_path"),
                                clap::Id::from("answer_path"),
                            ];
                            members
                        }),
                );
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new("json_path")
                        .value_name("JSON_PATH")
                        .required(true && clap::ArgAction::Set.takes_values())
                        .value_parser({
                            use ::clap_builder::builder::impl_prelude::*;
                            let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                String,
                            >::new();
                            (&&&&&&auto).value_parser()
                        })
                        .action(clap::ArgAction::Set);
                    let arg = arg
                        .help("input json file path")
                        .long_help(None)
                        .short('j')
                        .long("json-path")
                        .require_equals(false);
                    let arg = arg;
                    arg
                });
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new("answer_path")
                        .value_name("ANSWER_PATH")
                        .value_parser({
                            use ::clap_builder::builder::impl_prelude::*;
                            let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                String,
                            >::new();
                            (&&&&&&auto).value_parser()
                        })
                        .action(clap::ArgAction::Set);
                    let arg = arg
                        .help("answer file path")
                        .long_help(None)
                        .short('a')
                        .long("answer-path")
                        .require_equals(false);
                    let arg = arg;
                    arg
                });
            __clap_app.version("0.1.0").about("haversine")
        }
    }
    fn augment_args_for_update<'b>(__clap_app: clap::Command) -> clap::Command {
        {
            let __clap_app = __clap_app
                .group(
                    clap::ArgGroup::new("Args")
                        .multiple(true)
                        .args({
                            let members: [clap::Id; 2usize] = [
                                clap::Id::from("json_path"),
                                clap::Id::from("answer_path"),
                            ];
                            members
                        }),
                );
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new("json_path")
                        .value_name("JSON_PATH")
                        .required(true && clap::ArgAction::Set.takes_values())
                        .value_parser({
                            use ::clap_builder::builder::impl_prelude::*;
                            let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                String,
                            >::new();
                            (&&&&&&auto).value_parser()
                        })
                        .action(clap::ArgAction::Set);
                    let arg = arg
                        .help("input json file path")
                        .long_help(None)
                        .short('j')
                        .long("json-path")
                        .require_equals(false);
                    let arg = arg.required(false);
                    arg
                });
            let __clap_app = __clap_app
                .arg({
                    #[allow(deprecated)]
                    let arg = clap::Arg::new("answer_path")
                        .value_name("ANSWER_PATH")
                        .value_parser({
                            use ::clap_builder::builder::impl_prelude::*;
                            let auto = ::clap_builder::builder::_infer_ValueParser_for::<
                                String,
                            >::new();
                            (&&&&&&auto).value_parser()
                        })
                        .action(clap::ArgAction::Set);
                    let arg = arg
                        .help("answer file path")
                        .long_help(None)
                        .short('a')
                        .long("answer-path")
                        .require_equals(false);
                    let arg = arg.required(false);
                    arg
                });
            __clap_app.version("0.1.0").about("haversine")
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Args {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "Args",
            "json_path",
            &self.json_path,
            "answer_path",
            &&self.answer_path,
        )
    }
}
use std::sync::{LazyLock, Mutex};
use platform_metrics::read_cpu_timer;
use std::collections::HashMap;
pub struct Timer {
    pub name: String,
    pub start: u64,
}
#[automatically_derived]
impl ::core::clone::Clone for Timer {
    #[inline]
    fn clone(&self) -> Timer {
        Timer {
            name: ::core::clone::Clone::clone(&self.name),
            start: ::core::clone::Clone::clone(&self.start),
        }
    }
}
#[automatically_derived]
impl ::core::fmt::Debug for Timer {
    #[inline]
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        ::core::fmt::Formatter::debug_struct_field2_finish(
            f,
            "Timer",
            "name",
            &self.name,
            "start",
            &&self.start,
        )
    }
}
pub struct Timed {
    pub count: usize,
    pub cycles: u64,
}
impl Timer {
    pub fn new(name: &str) -> Self {
        let timer = Self {
            name: name.to_string(),
            start: read_cpu_timer(),
        };
        TIMING_STACK.lock().unwrap().push((timer.start, name.to_string()));
        timer
    }
}
impl Drop for Timer {
    fn drop(&mut self) {
        let function_end = read_cpu_timer();
        let mut lock = TIMING_STACK.lock().unwrap();
        let timer = lock.pop().expect("Pop on an empty vec");
        let cycles = function_end - timer.0;
        if lock.len() > 0 {
            let mut parent = lock.pop().unwrap();
            if parent.1 != &timer.1 {
                parent.0 += cycles;
                lock.push(parent);
            }
            lock.push(parent);
        }
        unsafe {
            TIMED
                .lock()
                .unwrap()
                .entry(timer.1.clone())
                .and_modify(|timed| {
                    timed.count += 1;
                    timed.cycles += cycles;
                })
                .or_insert(Timed { count: 1, cycles });
        }
    }
}
pub static TIMING_STACK: LazyLock<Mutex<Vec<(u64, String)>>> = LazyLock::new(|| Mutex::new(
    ::alloc::vec::Vec::new(),
));
pub static TIMED: LazyLock<Mutex<HashMap<String, Timed>>> = LazyLock::new(|| Mutex::new(
    HashMap::new(),
));
fn main() {
    use platform_metrics::{read_cpu_timer, read_os_timer, get_os_time_freq};
    let time_start = read_os_timer();
    let cpu_start = read_cpu_timer();
    let args = {
        use crate::Timer;
        let timer = Timer::new("startup");
        Args::parse()
    };
    let input = {
        use crate::Timer;
        let timer = Timer::new("read");
        String::from_utf8(fs::read(&args.json_path).expect("Unable to json read file"))
            .expect("Invalid utf-8 string")
    };
    let parsed_json = parse(&input);
    let sum = {
        use crate::Timer;
        let timer = Timer::new("sum");
        parsed_json
            .pairs
            .iter()
            .map(|pair| haversine(pair.x0, pair.y0, pair.x1, pair.y1, 6372.8))
            .sum::<f64>() / parsed_json.pairs.len() as f64
    };
    {
        ::std::io::_print(
            format_args!(
                "RESULTS\ninput size: {0}\nPair count: {1}\nHaversine sum: {2}\n\n",
                input.len(),
                parsed_json.pairs.len(),
                sum,
            ),
        );
    };
    if let Some(answer_path) = &args.answer_path {
        let answer = fs::read(answer_path)
            .expect("Unable to read answer file")
            .chunks(8)
            .skip(parsed_json.pairs.len())
            .map(|answer| {
                f64::from_le_bytes([
                    answer[0],
                    answer[1],
                    answer[2],
                    answer[3],
                    answer[4],
                    answer[5],
                    answer[6],
                    answer[7],
                ])
            })
            .collect::<Vec<f64>>()[0];
        {
            ::std::io::_print(
                format_args!(
                    "VALIDATION\nReference sum: {1}\nDifference: {0}\n\n",
                    sum - answer,
                    answer,
                ),
            );
        };
    }
    let cpu_end = read_cpu_timer();
    let time_end = read_os_timer();
    let total_cpu = cpu_end - cpu_start;
    let total_time = time_end - time_start;
    {
        ::std::io::_print(
            format_args!(
                "Total time: {0:.4}ms (CPU freq {1:.0})\n",
                total_time as f64 / 1_000.0,
                get_os_time_freq() as f64 * total_cpu as f64 / total_time as f64,
            ),
        );
    };
    TIMED
        .lock()
        .unwrap()
        .iter()
        .for_each(|(key, value)| {
            {
                ::std::io::_print(
                    format_args!(
                        "\t{0}[{1}]: {2} ({3:.2}%)\n",
                        key,
                        value.count,
                        value.cycles,
                        (value.cycles) as f64 / total_cpu as f64 * 100.0,
                    ),
                );
            };
        })
}
